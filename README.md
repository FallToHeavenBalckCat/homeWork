本周继续学习了图论与最短路，并对一部分图论与最短路的内容进行复习。在刷题的过程中遇到了一道异或前缀和+哈希表的题目，并且需要在题目中做相应的转化，下边是题解：
异或性质:相同数异或结果为0
异或前缀和:
s[i]表示前i个字母的异或前缀和,求[i ~ j]这一段的异或和:s[j] ^ s[i - 1]
因为s[j]是a[1] ^ a[2] ^ ... ^ a[i - 1] ^ a[i] ^ ... ^ a[j]
s[i - 1]是a[1] ^ a[2] ^ ... ^ a[i - 1]
所以s[j] ^ s[i - 1] == a[i] ^ ... ^ a[j],即是[i ~ j]这一段的异或和

条件1：该连续子数组的前一半元素的异或和等于其后一半元素的异或和
说明 左半边 ^ 右半边 = 0
假设这一连续子数组的下标是[i ~ j],所以即是[i ~ j]这一段的异或和等于0
所以s[j] ^ s[i - 1] == 0,所以由第一个条件可知 ==> s[j] == s[i - 1]
所以可以枚举每一个j,找到j左边异或前缀和与s[j]相等的数目,并加入到答案中
可以使用哈希表来记录之前的异或前缀和的值出现的次数
条件2：该连续子数组的长度为偶数
对于枚举没有一个j时,只需要将下标奇偶性与j相同的并且满足条件1的数目加到答案中即可。
在图论学习的过程中，遇到了一到很经典的题目：八数码问题，下边是题目的题解：
邻接链表,对于任意图 G = (V, E) 的某个节点 Adj[u] 表示节点 u 的邻接节点组成的一个链表
图的属性,对于任意图 G = (V, E) 的某个节点 u,u.d 表示从源节点 s 到节点 u 的距离
最短路径,对于任意图 G = (V, E) 的某两个节点 u, v,u 到 v 的最短路径为 u 到 v 的路径中边数最短的路
最短路径距离为
δ(u,v)=min边数u→⋯→v
δ(u,v)=min边数⁡u→⋯→v
若 u 到 v 没有路径, 则 δ(u,v)=∞
证明思路：
算法以源节点 s 为中心, 以广度优先的策略向四周探索节点, 直到探索完所有节点为止
广度优先搜索算法的详细思路
算法将节点分为三类
未探索的节点, 用白色表示
已探索的节点, 用黑色表示
边界节点(其实就是加入到队列里的节点), 用灰色表示
算法的核心代码依次重复执行下列操作
从队列中取出节点 u
扫描 Adj[u]
对于扫描到的白色节点 v, v 设为灰色, v.d = u.d + 1 后加入队列
扫描到灰色或黑色节点就跳过, 不进行任何操作
u 设为黑色
朴素做法大概分为两步：
1. 如果图中存在重边和自环，首先要对图进行预处理，对于重边，选择几条重边中最短的那条(因为邻接矩阵不支持重边)。
2. 对图进行初始化，用邻接矩阵表示，g[a][b]表示点a到点b的距离，开始的时候只要出发点到自己的距离是0，其余的点的距离上都是无穷，3. 用dist[k]表示第k个点到出发点的最短距离，表示结果，bool st[N]表示S集合，st[k]=true表示第K个点是在是集合中的
4. 具体思想及实现：
	4.1 遍历所有的点**找一个点不在S集合中距离最近的点t**（S集合表示已经找到最短路径的点）
	4.2 把t加入到S集合中
	4.3 用t更新其他所有点的距离，更新的方式，看从t出去的所有的边所组成的路径能不能更新其他点的距离，
Dijkstra算法的堆优化写法（其实很类似BFS的写法）,同朴素做法大致思路一样，只是取最短距离点的方式变成了从最小根堆取。
